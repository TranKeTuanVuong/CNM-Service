const messages = require("../models/Messages");
const ChatMembers = require("../models/ChatMember");
const Controller = require("../controller/index");
const Contacts = require("../models/Contacts");
const Users = require("../models/User");
const Chats = require("../models/Chat");

 

const socketHandler = (io) => {
  const users = {}; // L∆∞u tr·ªØ c√°c ng∆∞·ªùi d√πng v√† s·ªë ƒëi·ªán tho·∫°i c·ªßa h·ªç

  io.on("connection", (socket) => {
    console.log("üü¢ Client connected:", socket.id);

    // ƒêƒÉng k√Ω s·ªë ƒëi·ªán tho·∫°i c·ªßa ng∆∞·ªùi d√πng khi h·ªç k·∫øt n·ªëi
    socket.on("registerPhoneNumber", (phoneNumber) => {
      users[phoneNumber] = socket.id; // L∆∞u socket id v·ªõi s·ªë ƒëi·ªán tho·∫°i
      console.log(`User with phone number ${phoneNumber} connected`);
    });

    // Tham gia ph√≤ng ng∆∞·ªùi d√πng c√° nh√¢n
    socket.on("join_user", (userID) => {
      socket.join(userID);
      console.log(`üßç‚Äç‚ôÇÔ∏è Socket ${socket.id} joined user room: ${userID}`);
    });

    // Tham gia ph√≤ng chat c·ª• th·ªÉ
    socket.on("join_chat", (chatID) => {
      socket.join(chatID);
      console.log(`üîÅ Socket ${socket.id} joined chat room: ${chatID}`);
    });
    // update user
    socket.on("updateUser",async (data) => {
      try{
        const friends = await Controller.getContactsByUserID(data.userID);
        if (!friends) {
          io.to(data.userID).emit("update_user", data);
        } else{
          io.to(data.userID).emit("update_user", data);
        friends.forEach((friend) => {
          io.to(friend.userID).emit("updatee_user", data);
        });
      }
      }catch (error) {
        console.error("‚ùå Error updating user:", error);
      }
    });
      // update tr·∫°ng th√°i online/offline
    socket.on("updateStatus", async (data) => {
      try {
        //const { user} = data;
        const friends = await Controller.getContactsByUserID(data.userID);
        if (!friends) {
          console.error("‚ùå Kh√¥ng t√¨m th·∫•y b·∫°n b√® v·ªõi userID:", data.userID);
          return;
        }
        friends.forEach((friend) => {
          io.to(friend.userID).emit("status_update", data);
        });
        
      } catch (error) {
        console.error("‚ùå Error updating status:", error);
      }
    });

    // Tham gia ph√≤ng chat 1-1
    socket.on("createChat1-1", async (data) => {
      try {
        console.log("T·∫°o cu·ªôc tr√≤ chuy·ªán 1-1:", data);
        if (!data?.chatID) {
          console.error("‚ùå Kh√¥ng c√≥ chatID trong data");
          return;
        }
    
        
          data.members.forEach((member) => {
          io.to(member.userID).emit("newChat1-1",data);
          console.log(`üì§ G·ª≠i newChat1-1 ƒë·∫øn user ${member.userID}`);
        });
      } catch (error) {
        console.error("‚ùå Error creating chat:", error);
      }
    });
    
    // tin nh·∫Øn m·ªõi
   socket.on("send_message", async (data) => {
  try {
    const lastMessage = await messages.findOne().sort({ messageID: -1 });
    const nextID = lastMessage
      ? parseInt(lastMessage.messageID.replace("msg", ""), 10) + 1
      : 1;
    const messageID = `msg${String(nextID).padStart(3, "0")}`;
    let newMsg;
    if (data.replyTo){
       newMsg = new messages({
      messageID,
      chatID: data.chatID,
      senderID: data.senderID,
      content: data.content || "",
      type: data.type || "text",
      timestamp: data.timestamp || Date.now(),
      media_url: data.media_url || [],
      status: "sent",
      pinnedInfo: null,
      replyTo: data.replyTo,
    });
    }else{
      newMsg = new messages({
      messageID,
      chatID: data.chatID,
      senderID: data.senderID,
      content: data.content || "",
      type: data.type || "text",
      timestamp: data.timestamp || Date.now(),
      media_url: data.media_url || [],
      status: "sent",
      pinnedInfo: null,
      replyTo: null,
    });
  }

    const saved = await newMsg.save();

    const chatMembers = await ChatMembers.findOne({ chatID: data.chatID });
    const receiverIDs = chatMembers?.members
      .map((m) => m.userID)
      .filter((id) => id !== data.senderID);
    console.log("receiverIDs", receiverIDs);
    const fullMessage = {
      ...data,
      messageID: saved.messageID,
      timestamp: saved.timestamp,
      status: "sent",
      senderInfo: {
        name: data.senderInfo?.name || "Ng∆∞·ªùi d√πng",
        avatar: data.senderInfo?.avatar || null,
      },
    };

    // G·ª≠i t·ªõi ng∆∞·ªùi nh·∫≠n v√† ng∆∞·ªùi g·ª≠i
    receiverIDs.forEach((id) => io.to(id).emit("new_message", fullMessage));
    io.to(data.senderID).emit("new_message", fullMessage);
    io.to(data.chatID).emit(data.chatID, fullMessage);

    // C·∫≠p nh·∫≠t tr·∫°ng th√°i "delivered"
    setTimeout(async () => {
      await messages.findOneAndUpdate(
        { messageID: saved.messageID },
        { status: "delivered" }
      ).exec();

      io.to(data.chatID).emit(`status_update_${data.chatID}`, {
        messageID: saved.messageID,
        status: "delivered",
      });
    }, 1000);
  } catch (error) {
    console.error("‚ùå Error sending message:", error);
  }
});

    // socket.on("send_message", async (data) => {
    //   const messcount = await messages.findOne().sort({ messageID: -1 });
    //   const nextID = messcount
    //   ? parseInt(messcount.messageID.replace("msg", ""), 10) + 1
    //   : 1;
    // const messageID = `msg${String(nextID).padStart(3, "0")}`;
    //   const newMsg = new messages({
    //   messageID,
    //   chatID: data.chatID,
    //   senderID: data.senderID,
    //   content: data.content || "",
    //   type: data.type || "text",
    //   timestamp: data.timestamp || Date.now(),
    //   media_url: data.media_url || [],
    //   status: "sent",
    //   pinnedInfo: null,
    //   replyTo: null,
    // });
    // // L∆∞u message v√†o database
    // const saved = await newMsg.save();
    // if (!saved) {
    //   console.error("‚ùå Kh√¥ng th·ªÉ l∆∞u tin nh·∫Øn v√†o c∆° s·ªü d·ªØ li·ªáu");
    //   return;
    // }
    //   const lastMessage = await messages.findOne({ chatID: data.chatID }).sort({ timestamp: -1 });
    //   if (!lastMessage) {
    //     console.error("‚ùå Kh√¥ng t√¨m th·∫•y tin nh·∫Øn n√†o trong cu·ªôc tr√≤ chuy·ªán");
    //     return;
    //   }
    //   const chatMembers = await ChatMembers.find({ chatID: data.chatID });
    //   if (!chatMembers || chatMembers.length === 0) {
    //     console.error("‚ùå Kh√¥ng t√¨m th·∫•y th√†nh vi√™n n√†o trong cu·ªôc tr√≤ chuy·ªán");
    //     return;
    //   }
    //   const chat = await Chats.findOne({ chatID: data.chatID });
    //   if (!chat) {
    //     console.error("‚ùå Kh√¥ng t√¨m th·∫•y cu·ªôc tr√≤ chuy·ªán v·ªõi chatID:", data.chatID);
    //     return;
    //   }
    //   const mychat = {
    //     ...chat,
    //     members: chatMembers,
    //     lastMessage: lastMessage
    //   }
    //   const receiverIDs = chatMembers.map((m) => m.userID).filter((id) => id !== data.senderID);
    //   io.to(data.chatID).emit(data.chatID, mychat);
    //   receiverIDs.forEach((userID) => {
    //    // io.to(userID).emit("new_message", mychat);
    //     io.to(userID).emit("chat_update", mychat);
    //   });
    // });
    

    // C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë√£ ƒë·ªçc
    socket.on("read_messages", async ({ chatID, userID }) => {
      try {
        await messages.updateMany(
          { chatID, status: { $ne: "read" } },
          { status: "read" }
        );

        io.to(chatID).emit(`status_update_${chatID}`, {
          userID,
          status: "read",
        });

        io.to(userID).emit("status_update_all", {
          chatID,
          userID,
          status: "read",
        });
      } catch (err) {
        console.error("‚ùå Error updating read status:", err);
      }
    });
    socket.on("getContacts", async (userID) => {
      try {
        const contacts = await Controller.getContacts(userID);
        socket.emit("contacts", contacts);
      } catch (error) {
        console.error("‚ùå Error getting contacts:", error);
        socket.emit("error", { message: "L·ªói khi l·∫•y danh s√°ch li√™n h·ªá" });
      }
    });


// giui loi moi ket ban
socket.on("send_friend_request", async (data) => {
  // Ki·ªÉm tra xem recipientID c√≥ t·ªìn t·∫°i hay kh√¥ng
  if (!data.recipientID) {
    console.error("Recipient ID is missing or invalid.");
    return; 
  }
  try {
          const newContact = await Controller.createContact(data.senderID,data.recipientPhone);
  if (!newContact) {
    console.error("Failed to save new contact request.");
    return;
  }
  const User = await Users.findOne({ userID: data.senderID });
  if (!User) {
    console.error("Failed to find user for senderID:", data.senderID);
    return;
  }
  io.to(data.recipientID).emit("new_friend_request", {
    alias:newContact.alias,
    contactID: newContact.contactID,
    userID: data.recipientID,
    name: userRecipient.name,
    avatar: userRecipient.anhDaiDien,
  }); // G·ª≠i y√™u c·∫ßu k·∫øt b·∫°n ƒë·∫øn ng∆∞·ªùi nh·∫≠n
  const userRecipient = await Users.findOne({ userID: data.recipientID });
  if (!userRecipient) {
    console.error("Failed to find user for recipientID:", data.recipientID);
    return;
  }
  io.to(data.senderID).emit('friend_request_sent', {
    alias:newContact.alias,
    contactID: newContact.contactID,
    userID: data.recipientID,
    name: userRecipient.name,
    avatar: userRecipient.anhDaiDien,
  });
  }catch (error) {
    console.error("‚ùå Error sending friend request:", error);
    socket.emit("error", { message: "L·ªói server" });
  }
});


   

    
        
    // L·∫•y danh s√°ch chat c·ªßa user
    socket.on("getChat", async (userID) => {
      try {
        const chats = await Controller.getChatsForUser(userID);
        socket.emit("ChatByUserID", chats);
      } catch (error) {
        console.error("‚ùå Error getting chat list:", error);
        socket.emit("error", { message: "L·ªói khi l·∫•y danh s√°ch chat" });
      }
    });

    // ‚úÖ Thu h·ªìi tin nh·∫Øn
    socket.on("unsend_message", async ({ messageID, chatID, senderID }) => {
      try {
        const message = await messages.findOne({ messageID });

        if (!message ) {
          console.warn("‚ö†Ô∏è Unauthorized unsend or not found");
          return;
        }

        message.type = "unsend";
        message.content = "";
        message.media_url = [];
        await message.save();

        if (!message) {
          console.error("‚ùå Message not found:", messageID);
          return;
        }

        io.to(chatID).emit("unsend_notification", message);

        const members = await ChatMembers.find({ chatID });
        members.forEach((m) => {
          m.members.forEach((member) => {
            io.to(member.userID).emit("unsend_notification", message);
          });
        });

        console.log("‚ùå Message unsent:", messageID);
      } catch (error) {
        console.error("‚ùå Error unsending message:", error);
      }
    });

     // ‚úÖ ghim tin nh·∫Øn
    socket.on("ghim_message", async ({ messageID, chatID, senderID }) => {
      try {
        const message = await messages.findOne({ messageID });

        if (!message ) {
          console.warn("‚ö†Ô∏è Unauthorized ghim or not found");
          return;
        }

       message.pinnedInfo = {
         pinnedBy: senderID,
         pinnedAt: Date.now(),
       };
       await message.save();

        if (!message) {
          console.error("‚ùå Message not found:", messageID);
          return;
        }

        io.to(chatID).emit("ghim_notification", message);

        const members = await ChatMembers.find({ chatID });
        members.forEach((m) => {
          m.members.forEach((member) => {
            io.to(member.userID).emit("ghim_notification", message);
          });
        });

        console.log("‚ùå Message unsent:", messageID);
      } catch (error) {
        console.error("‚ùå Error unsending message:", error);
      }
    });
    // ‚úÖ unghim tin nh·∫Øn
    socket.on("unghim_message", async ({ messageID, chatID}) => {
      try {
        const message = await messages.findOne({ messageID });

        if (!message) {
          console.warn("‚ö†Ô∏è Unauthorized unghim or not found");
          return;
        }

       message.pinnedInfo = null;
       await message.save();

        if (!message) {
          console.error("‚ùå Message not found:", messageID);
          return;
        }

        io.to(chatID).emit("unghim_notification", message);

        const members = await ChatMembers.find({ chatID });
        members.forEach((m) => {
          m.members.forEach((member) => {
            io.to(member.userID).emit("unghim_notification", message);
          });
        });

        console.log("‚ùå Message unpinned:", messageID);
      } catch (error) {
        console.error("‚ùå Error unpinning message:", error);
      }
    });

    // ‚úÖ tr·∫£ l·ªùi tin nh·∫Øn
    socket.on("reply_message", async ({ messageID, chatID, senderID, content }) => {
      try {
        const message = await messages.findOne({ messageID });

        if (!message || message.senderID !== senderID) {
          console.warn("‚ö†Ô∏è Unauthorized reply or not found");
          return;
        }

        message.replyTo = {
          messageID: message.messageID,
          senderID: message.senderID,
          content: content,
          type: message.type,
          media_url: message.media_url,
        };
       await message.save();

        if (!message) {
          console.error("‚ùå Message not found:", messageID);
          return;
        }

        io.to(chatID).emit("reply_notification", message);

        const members = await ChatMembers.find({ chatID });
        members.forEach((m) => {
          m.members.forEach((member) => {
            io.to(member.userID).emit("reply_notification", message);
          });
        });

        console.log("‚ùå Message replied:", messageID);
      } catch (error) {
        console.error("‚ùå Error replying message:", error);
      }
    });

  // L·∫Øng nghe s·ª± ki·ªán accept_friend_request
  socket.on("accept_friend_request", async ({ senderID, recipientID, senderName, senderImage }) => {
    try {
      // 1. C·∫≠p nh·∫≠t tr·∫°ng th√°i y√™u c·∫ßu t·ª´ sender ‚Üí recipient
      const updatedRequest = await Contacts.findOneAndUpdate(
        { userID:recipientID , contactID: senderID, status: "pending" },
        { status: "accepted" },
        { new: true }
      );
  
  
      // 3. L·∫•y th√¥ng tin ng∆∞·ªùi nh·∫≠n (ƒë·ªÉ g·ª≠i l·∫°i qua socket)
      const userRecipient = await Users.findOne({ userID: recipientID });
       console.log("userRecipient",userRecipient);
      if (updatedRequest && userRecipient) {
        // 4. Emit t·ªõi ng∆∞·ªùi g·ª≠i
        io.to(recipientID).emit("friend_request_accepted", {
          userID:senderID,
          name:senderName,
          anhDaiDien:senderImage,
          status: "accepted",
        });
  
        // 5. Emit nguoi nhan
        io.to(senderID).emit("friend_request_accepted", {
          recipientID,
          status: "accepted",
        });
      }
    } catch (error) {
      console.error("‚ùå Error accepting friend request:", error);
    }
  });
  
      
  socket.on("reject_friend_request", async ({ senderID, recipientID, senderName, senderImage }) => {
    try {
      // 1. X√≥a y√™u c·∫ßu k·∫øt b·∫°n trong database
      const deletedRequest = await Contacts.findOneAndDelete({
        userID: recipientID,
        contactID: senderID,
        status: "pending",
      });
  
      // 2. L·∫•y th√¥ng tin ng∆∞·ªùi nh·∫≠n
      const userRecipient = await Users.findOne({ userID: recipientID });
  
      if (!deletedRequest || !userRecipient) {
        console.error("‚ùå Kh√¥ng t√¨m th·∫•y y√™u c·∫ßu k·∫øt b·∫°n ho·∫∑c ng∆∞·ªùi nh·∫≠n");
        return;
      }
  
      // 3. Emit t·ªõi ng∆∞·ªùi g·ª≠i
      io.to(recipientID).emit("friend_request_recipientID", {
        userID: senderID,
        name: senderName,
        avatar: senderImage, // Ensuring consistency with your code
        status: "rejected",
      });
  
      // 4. Emit t·ªõi ng∆∞·ªùi nh·∫≠n
      io.to(senderID).emit("friend_request_senderID", {
        recipientID,
        status: "rejected",
      });
  
      console.log(`‚úîÔ∏è ƒê√£ t·ª´ ch·ªëi y√™u c·∫ßu k·∫øt b·∫°n t·ª´ ${senderID} t·ªõi ${recipientID}`);
    } catch (error) {
      console.error("‚ùå Error rejecting friend request:", error);
    }
  });
  
  
      

    

   
    
    

    // L·∫Øng nghe s·ª± ki·ªán get_pending_friend_requests
    socket.on("get_pending_friend_requests", async (userID) => {
      try {
        // G·ªçi controller ƒë·ªÉ l·∫•y danh s√°ch y√™u c·∫ßu k·∫øt b·∫°n ƒëang ch·ªù
        const friendRequests = await Controller.displayFriendRequest(userID);
        socket.emit("pending_friend_requests", friendRequests); // G·ª≠i l·∫°i th√¥ng tin y√™u c·∫ßu k·∫øt b·∫°n ƒëang ch·ªù
      } catch (error) {
        console.error("‚ùå Error fetching pending friend requests:", error);
        socket.emit("error", { message: "L·ªói khi l·∫•y y√™u c·∫ßu k·∫øt b·∫°n" });
      }
    });
    socket.on("AddMember", async (data) => {
      try {
        // Th√™m th√†nh vi√™n v√†o nh√≥m
        const chat = await Controller.addMembersToGroup(data.chatID, data.members);
        
        // Ki·ªÉm tra xem nh√≥m c√≥ t·ªìn t·∫°i hay kh√¥ng
        if (!chat) {
          console.error("‚ùå Kh√¥ng t√¨m th·∫•y nh√≥m ho·∫∑c kh√¥ng th·ªÉ th√™m th√†nh vi√™n");
          return;
        }
     console.log("Th√™m th√†nh vi√™n v√†o nh√≥m:", chat);
        const newMembers = chat.members;
    
        // L·∫•y th√¥ng tin ƒë·∫ßy ƒë·ªß c·ªßa c√°c th√†nh vi√™n m·ªõi
        const Informember = await Controller.getInforMember(newMembers);
    
        // G·ª≠i socket event t·ªõi t·∫•t c·∫£ th√†nh vi√™n
        newMembers.forEach((member) => {
          const socketID = member.userID;
    
          // G·ª≠i th√¥ng tin th√†nh vi√™n m·ªõi ƒë·∫øn t·ª´ng ng∆∞·ªùi
          io.to(socketID).emit("newMember", Informember);
    
          // G·ª≠i b·∫£n c·∫≠p nh·∫≠t nh√≥m m·ªõi (chat) ƒë·∫øn t·ª´ng ng∆∞·ªùi
          io.to(socketID).emit("updateChat",chat);
        });
    
      } catch (error) {
        console.error("‚ùå Error adding member:", error);
      }
    });

    socket.on("removeMember", async (data) => {
      const { chatID, memberID } = data;
    
      try {
        // G·ªçi controller ƒë·ªÉ x√≥a th√†nh vi√™n
        const chat = await Controller.userRemoveFromGroup(chatID, memberID);
        
        // Ki·ªÉm tra xem nh√≥m c√≥ t·ªìn t·∫°i hay kh√¥ng
        if (!chat) {
          console.error("‚ùå Kh√¥ng t√¨m th·∫•y nh√≥m ho·∫∑c kh√¥ng th·ªÉ x√≥a th√†nh vi√™n");
          return;
        }
        console.log("X√≥a th√†nh vi√™n kh·ªèi nh√≥m:", chat);
        // Ki·ªÉm tra xem members c√≥ t·ªìn t·∫°i v√† c√≥ d·ªØ li·ªáu kh√¥ng
        if (!chat.members || chat.members.length === 0) {
          console.error("‚ùå Kh√¥ng c√≥ th√†nh vi√™n trong nh√≥m sau khi x√≥a.");
          return;
        }
        const newMembers = chat.members;
        // L·∫•y th√¥ng tin ƒë·∫ßy ƒë·ªß c·ªßa c√°c th√†nh vi√™n m·ªõi
        const Informember = await Controller.getInforMember(newMembers);
    
        if (!Informember || Informember.length === 0) {
          console.error("‚ùå Kh√¥ng th·ªÉ l·∫•y th√¥ng tin th√†nh vi√™n m·ªõi.");
          return;
        }
        io.to(memberID).emit("removeChatt", chatID); 
        // G·ª≠i socket event t·ªõi t·∫•t c·∫£ th√†nh vi√™n
        newMembers.forEach((member) => {
          const socketID = member.userID;
          // G·ª≠i th√¥ng tin th√†nh vi√™n m·ªõi ƒë·∫øn t·ª´ng ng∆∞·ªùi
          io.to(socketID).emit("outMember", Informember);
      
          // G·ª≠i b·∫£n c·∫≠p nh·∫≠t nh√≥m m·ªõi (chat) ƒë·∫øn t·ª´ng ng∆∞·ªùi
          io.to(socketID).emit("updateMemberChat", chat);
        });
    
      } catch (error) {
        console.error("Error removing member:", error);
        socket.emit("removeMemberResponse", { success: false, message: "L·ªói khi x√≥a th√†nh vi√™n." });
      }
    });
    socket.on("updateAdmin", async (data) => {
      try {
        const { chatID, adminID, memberID } = data;
    
        // G·ªçi controller ƒë·ªÉ c·∫≠p nh·∫≠t admin
        const chat = await Controller.transferRole(chatID, adminID, memberID);
    
        console.log("C·∫≠p nh·∫≠t quy·ªÅn admin:", chat);
        // Ki·ªÉm tra l·ªói t·ª´ controller
        if (!chat || chat.error) {
          console.error("‚ùå Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t quy·ªÅn admin:", chat?.error || "L·ªói kh√¥ng x√°c ƒë·ªãnh");
          return;
        }
    
        // Ki·ªÉm tra members t·ªìn t·∫°i
        if (!chat.members || chat.members.length === 0) {
          console.error("‚ùå Kh√¥ng c√≥ th√†nh vi√™n trong nh√≥m sau khi chuy·ªÉn quy·ªÅn.");
          return;
        }
    
        const newMembers = chat.members;
        console.log("‚úÖ Th√†nh vi√™n m·ªõi sau khi chuy·ªÉn quy·ªÅn:", newMembers);
    
        // L·∫•y th√¥ng tin th√†nh vi√™n
        const Informember = await Controller.getInforMember(newMembers);
    
        if (!Informember || Informember.length === 0) {
          console.error("‚ùå Kh√¥ng th·ªÉ l·∫•y th√¥ng tin th√†nh vi√™n.");
          return;
        }
    
        console.log("‚úÖ Th√¥ng tin th√†nh vi√™n m·ªõi:", Informember);
    
        // G·ª≠i socket ƒë·∫øn c√°c th√†nh vi√™n
        newMembers.forEach((member) => {
          const socketID = member.userID;
    
          io.to(socketID).emit("UpdateRole", Informember);   // G·ª≠i danh s√°ch th√†nh vi√™n c·∫≠p nh·∫≠t
          io.to(socketID).emit("updateChatmember", chat);         // G·ª≠i d·ªØ li·ªáu nh√≥m m·ªõi
        });
    
      } catch (error) {
        console.error("‚ùå L·ªói khi c·∫≠p nh·∫≠t admin:", error);
      }
    });

    socket.on("deleteGroupAndMessages", async (data) => {
      try{
      const { chatID } = data;
      const chatmember = await ChatMembers.findOne({ chatID });
      if (!chatmember) {
        console.error("‚ùå Kh√¥ng t√¨m th·∫•y nh√≥m v·ªõi chatID:", chatID);
        return;
      }
      const result = await Controller.deleteGroupAndMessages(chatID);
      if (!result) {
        console.error("‚ùå Kh√¥ng th·ªÉ x√≥a nh√≥m ho·∫∑c kh√¥ng t√¨m th·∫•y nh√≥m v·ªõi chatID:", chatID);
        return;
      }
      chatmember.members.forEach((member) => {
        const socketID = member.userID;
        io.to(socketID).emit("removeChatt", chatID); // G·ª≠i th√¥ng b√°o x√≥a nh√≥m cho t·∫•t c·∫£ th√†nh vi√™n
      });
    }catch (error) {
      console.error("‚ùå L·ªói khi x√≥a nh√≥m v√† tin nh·∫Øn:", error);
    }
    });
    socket.on("deleteMember", async (data) => {
      try {
        const {chatID,adminID, memberID} = data;
        const chat = await Controller.removeMemberFromGroup(chatID, adminID, memberID);
        if (!chat) {
          console.error("‚ùå Kh√¥ng t√¨m th·∫•y nh√≥m ho·∫∑c kh√¥ng th·ªÉ x√≥a th√†nh vi√™n");
          return;
        }
        console.log("X√≥a th√†nh vi√™n kh·ªèi nh√≥m:", chat);
        const newMembers = chat.members;
        // L·∫•y th√¥ng tin ƒë·∫ßy ƒë·ªß c·ªßa c√°c th√†nh vi√™n m·ªõi
        const Informember = await Controller.getInforMember(newMembers);
        if (!Informember || Informember.length === 0) {
          console.error("‚ùå Kh√¥ng th·ªÉ l·∫•y th√¥ng tin th√†nh vi√™n m·ªõi.");
          return;
        }
          io.to(memberID).emit("removeChattt", chatID); // G·ª≠i th√¥ng b√°o x√≥a nh√≥m cho th√†nh vi√™n ƒë√£ b·ªã x√≥a
         // return; // B·ªè qua th√†nh vi√™n ƒë√£ b·ªã x√≥a
        // G·ª≠i socket event t·ªõi t·∫•t c·∫£ th√†nh vi√™n
        newMembers.forEach((member) => {
          const socketID = member.userID;
          // G·ª≠i th√¥ng tin th√†nh vi√™n m·ªõi ƒë·∫øn t·ª´ng ng∆∞·ªùi
          io.to(socketID).emit("outMemberr", Informember);
      
          // G·ª≠i b·∫£n c·∫≠p nh·∫≠t nh√≥m m·ªõi (chat) ƒë·∫øn t·ª´ng ng∆∞·ªùi
          io.to(socketID).emit("updateMemberChattt", chat);
        });
      
      }
      catch (error) {
        console.error("‚ùå L·ªói khi x√≥a th√†nh vi√™n:", error);
      }
    });
     socket.on("call-user", (data) => {
    io.to(data.to).emit("call-made", {
      offer: data.offer,
      from: socket.id,
    });
  });

  socket.on("make-answer", (data) => {
    io.to(data.to).emit("answer-made", {
      answer: data.answer,
      from: socket.id,
    });
  });

  socket.on("ice-candidate", (data) => {
    io.to(data.to).emit("ice-candidate", {
      candidate: data.candidate,
      from: socket.id,
    });
  });
        
    // Ng·∫Øt k·∫øt n·ªëi
    socket.on("disconnect", () => {
      console.log("üî¥ Client disconnected:", socket.id);
    });
  });
};

module.exports = socketHandler;
